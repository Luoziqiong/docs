### 1. 理解`Node`在应用程序中的作用，可以使用`Node`搭建前端运行环境、使用`Node`操作文件、操作数据库等等

### 2. 掌握一种`Node`开发框架，如`Express`、`Express`和`Koa`的区别

### 3. 熟练使用`Node`提供的`API`的`Path`、`Http`、`ChildProcess`等并理解其实现原理

### 4. `Node`的底层运行原理和浏览器的异同, (`Node`与`JavaScript`有什么不同？)

|`JavaScript`                        | `Node.js`                            |
| -------------------------------| :------------------------------------------|
| `JavaScript`是一种变成语言，可以在任何有合适浏览器引擎的网络浏览器中运行。| `Node.js`是为`JavaScript`设计的解释器和运行时环境。`Node.js`内置了一些增强`JavaScript`编程功能的模块。|
| 除了`Node.js`，`JavaScript`用于网络应用程序的客户端，特别是用于开发动态特性。| `Node.js`可以在任何操作系统上用于开发与系统硬件交互的应用程序，特别是对于 web 后端。|
| `JavaScript`可以在不同浏览器引擎上运行，比如`V8（Google Chrome）`、`Spider Monkey（Firefox）`和`JavaScript Core（Safari）`。 | `Node.js`仅在`Chrome`使用的`V8`引擎上运行。|

### 5. 什么时候用`Node.js`？

`Node.js`是异步的，事件驱动的、非阻塞的和单线程的，使得他成为开发下面应用程序的完美候选：

- 实时应用程序，如聊天和提供实时更新的应用程序。
- 将视频或其他多媒体内容流式传输给大量观众的流式应用程序。
- 其他 I/O 密集型应用程序，如协作平台
- 遵循微服务架构的网络后端

然而，`Node.js` 的特性使得它对于其他类型的应用程序来说不是一个理想的选择。执行 `CPU` 密集型任务的应用程序（如复杂的数学计算）在使用 `CPU` 时表现不佳，因为 `Node.js` 是单线程的。

### 6. `EventEmitter` 做了什么？

`Node.js` 中任何对象发出的事件都是 `EventEmitter` 类的实例，就像 `http` 模块。
所有 `EventEmitter` 类都可以使用 `eventEmitter.on()`函数将事件侦听器附加到事件。然后一旦捕捉到这样的事件。就会同步的逐个调动他的侦听器。

```
const events = require("events");
const eventEmitter = new events.EventEmitter();
const eventListener = function () {
  console.log("event triggered");
}
eventEmitter.on('emitted', eventListener);
eventEmitter.emit('emitted');
```

### 7. `Node`事件驱动、非阻塞机制的实现原理

由于Node.js是单线程，要实现非阻塞，事件循环负责实现这种非阻塞卫星，它使应用程序线程调度挂起的任务，

Node.js在任务完成时通过回调来处理异步函数返回的响应。与创建任务的事件类似，任务完成后也会发出一个时间，Node.js将需要处理的事件添加到事件队列。

事件循环对事件队列中的事件进行迭代，并安排何时执行其相关联的回调函数。
```
   ┌───────────────────────────┐
┌─>│           timers          │  setTimeout,setInterval回调函数
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │  执行延迟到下一个循环迭代的 I/O 回调
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │  node内部使用
│  └─────────────┬─────────────┘      ┌───────────────┐ 检索新的 I/O 事件;
│  ┌─────────────┴─────────────┐      │   incoming:   │ 执行与 I/O 相关的回调
│  │           poll            │<─────┤  connections, │ （几乎所有情况下，除了关闭的回调函数，那些由计时器
│  └─────────────┬─────────────┘      │   data, etc.  │ 和 setImmediate() 调度的之外）其余情况 node 将在适当的时候在此阻塞
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │  setImmediate() 回调函数在这里执行
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │  一些关闭的回调函数，如：socket.on('close', ...)
   └───────────────────────────┘

```
### 8. 流是什么
Stream 流是从源读取或写入数据并将其传输到连续流目标的管道。有四种类型：

- 可读

- 可写的

- 可读写

- 先写入，再读出来

每个流也是一个 EventEmitter。这意味着流对象可以在流上没有数据、流上有可用数据或流中的数据在程序刷新时发出事件。

### 9. readFile 和 createReadStream 函数有什么区别？
readFile 函数异步读取文件的全部内容，并存储在内存中，然后再传递给用户。

createReadStream 使用一个可读的流，逐块读取文件，而不是全部存储在内存中。

与 readFile 相比，createReadStream 使用更少的内存和更快的速度来优化文件读取操作。如果文件相当大，用户不必等待很长时间直到读取整个内容，因为读取时会先向用户发送小块内容。

### 11. 如何处理 Node.js 中未捕获的异常？
我们可以在进程级别捕获应用程序中未捕获的异常。为此将侦听器附加到 process 全局对象：
```
process.on("uncaughtException", (err) => {
  console.log("exception caught: ", err);
});
```
### 12. Node.js 能否充分利用多核处理器？
（默认的）Node.js 应用程序总是单线程的，即使在多核处理器上运行，应用程序也能只使用一个处理器。

但是 Node.js 的核心模块之一 Cluster 支持 Node.js 应用程序开启多核，允许我们创建多个工作进程，这些进程可以在多个内核上并行运行，并共享一个端口来侦听事件。

每个进程使用 IPC 与主线程通信，并根据需要将服务器句柄传递给其他进程。主进程可以侦听端口本身并以循环方式将每个新连接传递给子进程，也可以将端口分配给子进程以便子进程侦听请求。

### 13. 单线程与多线程网络后端相比有哪些好处？

简单，开销小
### 14. process.nextTick 和 setImmediate 有什么区别？
执行时机不同，process.nextTick是微任务，每个事件阶段结束后，都可以执行。setImmediate是宏任务，只在check事件阶段执行。
 

