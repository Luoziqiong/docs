### 1. 各浏览器使用的`JavaScript`引擎以及它们的异同点，如何在代码中进行区分

https://zhuanlan.zhihu.com/p/32751855

### 2. 请求数据到请求结束与服务器进行了几次交互

### 3. 可详细描述浏览器从输入`URL`到页面展现的详细过程

#### 应用层

(1) URL 编码
一般来说，URL 只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。
那么当 URL 中包含汉字时，需要对其进行编码处理，以符合规范。

- 情况 1：URL 路径包含汉字

例如： `http://zh.wikipedia.org/wiki/春节`会被编译成`https://zh.wikipedia.org/wiki/%E6%98%A5%E7%AF%80`

如果 URL 路径中包含了汉字会使用 utf-8 进行编码

- 情况 2：URL 查询参数上包含汉字
  查询字符串的编码，用的是操作系统的默认编码

另外，在 HTTP 协议中参数组件的的传输是通过`key=value`的方式进行传递的，传递多个参数会要加上`&`符号，将每个参数进行分隔。

如果我要传递的参数值包含了`=`和`&`这两个字符，此时就会引起错误，因此这个时候对参数值内的值进行编码处理之后，我们就可以完整且正确的传递参数值。
例如：`name1=va&lu=e1`编译成`name1=va%26lu%3De1`

此处我们可以使用`encodeURIComponent`对参数值进行编码。

```
encodeURI()和encodeURIComponent() 区别？

URI: Uniform Resource Identifiers, 通用资源标识符

Global对象的encodeURI()和encodeURIComponent()方法可以对URI进行编码，以便发送给浏览器。有效的URI中不能包含某些字符，例如空格。而这URI编码方法就可以对URI进行编码，它们用特殊的UTF-8编码替换所有无效的字 符，从而让浏览器能够接受和理解。

其中encodeURI()主要用于整个URI(例如，http://www.jxbh.cn/illegal value.htm)，而encode-URIComponent()主要用于对URI中的某一段(例如前面URI中的illegal value.htm)进行编码。

它们的主要区别在于，encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；
而encodeURIComponent()则会对它发现的任何非标准字符进行编码。

来看下面的例子：
var uri="http://www.jxbh.cn/illegal value.htm#start";
alert(encodeURI (uri))
//”http: //www.jxbh.cn/illegal%20value .htm#s tart”
alert( encodeURIComponent (uri))
//”http% 3A%2F%2Fwww.jxbh.cn%2Fillegal%20value. htm%23 start”

使用encodeURI() 不会对ASCII字母、数字、~!@#$&*()=:/,;?+' 进行编码。
而encodeURIComponent()方法不会对ASCII字母、数字、~!*()' 进行编码。
这也正是可以对整个URI使用encodeURI()，而只能对附加在现有URI后面的字符串使用encodeURIComponent()的原因所在。一般来说,我们使用encodeURIComponent()方法的时候要比使用encodeURI()更多,因为在实践中更常见的是对查询字符串参数而不是对基础URL进行编码.

```

(2)生成 HTTP 请求信息
请求报文：请求行+消息头+消息体
（响应报文：状态行+消息头+消息体）

(3)DNS 查询
在上一步得到正确的网址之后，接下来需要将网址转换成可访问的 IP 地址。

- 为什么需要 DNS 解析域名为 IP 地址？
  网络通讯大部分是基于`TCP/IP`的，而`TCP/IP`是基于 IP 地址的，所以计算机在网络上进行通讯时只能识别 IP 地址，而不能认识域名。我们无法记住超过 10 个以上的 IP 地址，因此我们在访问网站时，更多时候是使用域名去访问。所以需要使用 DNS 来解析域名。

DNS 记录会有一个 ttl 值(time to live)，单位是秒，意思是这个记录最大有效期是多少。

通过 DNS 查询到网址对应的 IP 地址。查询优先级如下。以`https://www.baidu.com`为例：

1.  浏览器中的 DNS 缓存，浏览器 DNS 缓存的时间跟 ttl 值无关，每种浏览器都使用一个固定值，所以在浏览器 DNS 缓存失效前访问，会直接取浏览器 DNS 缓存中的映射地址。
2.  如果浏览器 DNS 缓存失效，查询本地 hosts 文件有无映射，如果有直接返回
3.  如果 hosts 文件没有域名映射，查询本地 DNS 服务器，如果有直接返回
4.  如果要查询的域名，不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析，此解析不具有权威性。
5.  如果本地 DNS 服务器本地区域文件与缓存解析都失效，则根据本地 DNS 服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地 DNS 就把请求发至 13 台根 DNS，根 DNS 服务器收到请求后会判断这个域名(`.com`)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个 IP。本地 DNS 服务器收到 IP 信息后，将会联系负责.com 域的这台服务器。这台负责`.com`域的服务器收到请求后，如果自己无法解析，它就会找一个管理`.com`域的下一级 DNS 服务器地址(`http://baidu.com`)给本地 DNS 服务器。当本地 DNS 服务器收到这个地址后，就会找`http://baidu.com`域服务器，重复上面的动作，进行查询，直至找到`www.baidu.com`主机
6.  如果用的是转发模式，此 DNS 服务器就会把请求转发至上一级 DNS 服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根 DNS 或把转请求转至上上级，以此循环。不管是本地 DNS 服务器用是是转发，还是根提示，最后都是把结果返回给本地 DNS 服务器，由此 DNS 服务器再返回给客户机。

#### 传输层

(4)生成 TCP 报文
完成上面的不收之后浏览器通过调用 Socket 库，来委托协议栈工作。由于 HTTP 是基于 TCP 协议传输的，所以接下来由 TCP 来接手
报文中包含了源地址和目标地址的端口信息

- TCP 三次握手

1.  客户端发送 SYN 同步标识，表示通知服务器，想要建立连接
2.  服务端收到标识之后返回一个 ACK 确认标识和 SYN 同步标识，表示收到你的消息，可以建立连接
3.  客户端收到服务端返回的标识之后，再发送一个 ACK 确认标识，通知服务端，我也可以正确的接收到你的消息。

至此，一个可靠的传输通道就建立起来了。

> 为什么需要三次不能两次呢？因为前面两次，让客户端知道服务端是可以正常收到我的消息的，但是服务端不知道自己传送回去的消息客户端是不是可以正常收到，所以最后一步是为了让服务端确认自己发送给客户端的消息也是可以正常到达的。保证了传输的可靠性。
> 保证双方都有收发消息的能力

接下来 `TCP` 会给 `HTTP` 数据包上一层 `TCP` 头信息，如果 `HTTP` 报文过长时，会对齐进行分割，分多次传输。生成 `TCP` 报文之后交给 `IP` 模块(网络层)来处理。

- TCP 四次挥手
  数据传输完毕之后，`TCP` 协议需要关闭刚才建立起来的连接。

1. 客户端发送一个 `FIN` 结束标识和一个希望接受者看到自己的当前序列号 `K`，表示通知服务端，自己想要断开连接，同时还包含一个 `ACK` 表示确认最近一次发过来的数据。
2. 服务端将 `K` 值加 1 作为 `ACK` 的序号值，表明收到了上一个包。
3. 通常服务端发起自己的 `FIN` 字段，ACK=K+1，Seq=L
4. 客户端确认。ACK=L+1
   至此，连接关闭

#### 网络层

TCP 模块在执行连接、收发、断开等各阶段的操作时，都需要委托 IP 模块将数据封装成网络包发送给通信对象。

(5)生成 IP 报文
IP 模块会根据协议，在上面的 TCP 报文外包一层 IP 头部信息，生成了 IP 报文。
报文中包含了源地址和目标地址的 IP 地址

#### 链路层

(6)生成 MAC 报文
在生成 IP 头部之后，还需要在外层载包上一层 MAC 头部。里面包含了源地址和目标地址的 MAC 地址

MAC 地址是网卡生产时写入到 ROM 里面的，所以只要将该值读取出来写入 MAC 头部即可。本机的 MAC 地址很容易获得，那么目标地址的 MAC 地址如何获得呢？

通过 ARP 协议可以找到路由器的 MAC 地址。

#### 物理层

(7)通过网卡，交换机和路由器等设备，将数据最终传送到服务端。

然后在服务其中，逆过程，一层层剥掉之前加上的头信息，得到原始的 HTTP 数据。

就这样循环往复上面的过程直到客户端得到所有需要的数据，发起四次挥手。

接下来就是下面一题的事情了，不在这题里面写了。

[参考文章](https://www.cnblogs.com/cangqinglang/p/13201388.html)

### 4. 浏览器解析`HTML`代码的原理，以及构建`DOM`树的流程

解析规则：从上至下解析，遇到 script 标签会阻塞解析，如果是一段代码，直接执行，如果是路径或网络文件，则加载该文件并执行。但是如果 script 标签上到有 async 和 defer 标识不会阻塞执行。async 标识表示不阻塞解析，当资源加载完成时执行，defer 标识不阻塞执行，当 DOM 解析完成时执行，相当于将 Script 移到了 body 标签的尾部

DOM 树构建流程：
第一步：将 HTML 解析成一个个 Token(Token 是编译原理里的一个术语，它表示最小的有意义的单元)
第二步：根据 Token 构建 DOM 树
在 chrome 里，总共定义了 7 中 Token 类型

```
enum TokenType {
    StartTag,
    EndTag,
    Comment,
    Character,
    Uninitialized,
    DOCTYPE,
    EndOfFile,
};
```

Token 用栈存储，文档全部解析完后，栈中的信息弹出，按照规则组成一颗 DOM 树

https://xie.infoq.cn/article/9066d97f021319a6bac5f9eb5

### 5. 浏览器如何解析 CSS 规则，并将其应用在 DOM 树上

解析 `CSS` 会产生 `CSS` `规则树，html` 不是与上下文无关的语法，而 `css` 和 `js` 是与上下文无关的语法，所以常规的解析方法都可以用。对于建立 `CSS` 规则树，是需要比照着 `DOM` 树来的。`CSS` 匹配 `DOM` 树主要是从右到左解析 `CSS` 选择器。解析 `CSS` 的顺序是浏览器的样式 -> 用户自定义的样式 -> 页面的 `link` 标签等引进来的样式 -> 写在 `style` 标签里面的内联样式

样式表不会更改 `DOM` 树，因此没有必要等待样式表并停止文档解析。而脚本在文档解析阶段会请求样式信息时还没有加载和解析样式，脚本就会获得错误的回复。`Firefox` 在样式表加载和解析的过程中，会禁止所有脚本。而对于 `WebKit` 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。

### 6. 浏览器如何将解析好的带有样式的 DOM 树进行绘制
首先会计算几何形状进行布局，渲染树构建好了之后，将会执行布局过程，将确定每个节点在屏幕上的确切坐标。

然后遍历渲染树，使用UI层绘制每个节点。
### 7. 浏览器的运行机制，如何配置资源异步同步加载

### 8. 浏览器回流与重绘的底层原理，引发原因，如何有效避免

    - 回流（重排）
    原因：1、添加/删除dom元素
        2、元素位置或尺寸改变
        4、元素内容变化（文字数量或图片大小等等）
        5、元素字体大小变化
        6、浏览器尺寸变化
        7、页面渲染初始化
        8、激活CSS伪类
        9、查询调用尺寸相关的方法
        一些常用且会导致回流的属性和方法：
        ```
        clientWidth、clientHeight、clientTop、clientLeft
        offsetWidth、offsetHeight、offsetTop、offsetLeft
        scrollWidth、scrollHeight、scrollTop、scrollLeft
        scrollIntoView()、scrollIntoViewIfNeeded()
        getComputedStyle()
        getBoundingClientRect()
        scrollTo()
        ```
    - 重绘
    原因：页面匀速样式改变，但没有上面引发回流的行为时，（例如：color等）

    回流必会重绘

    - 避免措施：
    CSS：
    1、避免使用table布局
    2、尽可能在DOM树的最末端改变class
    3、避免设置多层内联样式
    4、将动画效果应用到position属性为absolute和fixed的元素上。
    5、避免使用CSS表达式

    JavaScript：
    1、避免频繁的操作样式，最好一次性重写style属性，或者将列表样式定义为class并一次性更改class属性
    2、避免频繁操作DOM，创建一个documentFragment，在它上面应用所有Dom操作，最后在把他添加到文档中
    3、也可以先设置元素为display:none，操作结束后再把它显示出来。
    4、避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来
    5、对具有复杂动画的元素使用绝对定位，是他脱离文档流。否则会硬气父元素及后续元素频繁的回流。

### 9. 浏览器的垃圾回收机制，如何避免内存泄露

    传统浏览器的垃圾回收机制：

    - 标记清除：变量进入环境时标记为‘进入环境’，离开环境时标记为‘离开环境’，回收是标记为‘离开环境’的变量会被回收。
    - 引用计数：根据变量被引用数为其计数，引用数为 0 的变量在回收时会被清除

    V8 引擎回收策略：
    由于垃圾回收的事件，

### 10. 浏览器采用的缓存方案，如何选择和控制合适的缓存方案

    - Service Worker

    - Memory Cache

    - Disk Cache

    - Push Cache
