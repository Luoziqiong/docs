### 1. 理解词法作用域和动态作用域
   词法作用域，也可以称为静态作用域，指的是作用域是在函数定义时就被确定了。
   动态作用域，作用域在代码运行时才会被确定。|
   JS 采用的是词法作用域。

### 2. 上下文与作用域的关系？

   当代码运行时，会产生一个对应的执行环境，在这个环境中，所有变量会被事先提出来（变量提升），有的直接赋值，有的为默认值`undefined`，代码从上往下执行，就叫做执行上下文。

   JS 中有三种运行环境：

   - 全局环境：代码首先进入的环境
   - 函数环境：函数被调用时执行的环境
   - `eval`函数

   - 执行上下文生命周期

     1. 创建阶段

     (1) 生成变量对象

     (2) 建立作用域链

     (3) 确认`this`指向

     2. 执行阶段

     (1) 变量赋值

     (2) 函数引用

     (3) 执行其他代码

     3. 销毁阶段

     执行完毕出栈, 等待回收被销毁

     `JavaScript`代码执行过程分为两个阶段：

     - 代码解释阶段：由编译器完成，将代码翻译成可执行代码。
     - 代码执行阶段：有引擎完成，主要任务是执行可执行代码。

     **解释阶段**

     - 词法分析
     - 语法分析
     - 作用域规则确定

     **执行阶段**

     - 创建执行上下文
     - 执行函数代码
     - 垃圾回收

     作用域在函数定义时被确定，执行上下文是在函数执行之前创建的。

     作用域和执行上下文之间最大的区别是： **执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。**

### 3. 理解`JavaScript`的作用域和作用域链

   作用域指的是你有权访问的变量， 对象， 函数的集合。作用域决定了你代码区块中变量和其他资源的可见性。
   作用域最大的用处是隔离变量，不同作用域下面的同名变量不会有冲突。

   - 全局作用域

     在代码中任何地方都能访问到的对象拥有全局作用域。比如最外层函数，最外层变量。

     `window`对象的内置属性拥有全局作用域。

   - 函数作用域

     函数作用域，是指在函数内部声明的变量函数的集合。只有在该函数内部才可以访问到。

     内层作用域可以访问外层作用域，反之则不行。

     块语句不会创建新的作用域。在块语句中定义的变量将保留他们已经存在的作用域中。

   - 块级作用域
     块级作用域可通过新增命令`let`和`const`声明， 所声明的变量在指定块的作用域外无法被访问。块级作用域在如下情况被创建：

   - 在一个函数的内部
   - 在一个代码块（由一对花括号包裹）内部

   - 作用域链
     > 作用域链本质上是一个指向当前环境与上层环境的一系列变量对象的指针列表（它只引用但不实际包含变量对象），作用域链保证了当前执行环境对符合访问权限的变量和函数的有序访问。

   在一个作用域中访问一个变量，如果这个变量没有在该作用域声明，此时就会往该作用域的上一级作用域（即创建该函数的作用域）去找。取到的值为离自己最近的作用域里的值。

   这样就形成了一个链式结构。

### 4. 理解`JavaScript`的执行上下文栈，可以应用堆栈信息快速定位问题

   执行上下文栈会存储执行环境，执行全局代码时，全局环境首先会被压入栈中，之后执行到函数时，会向栈中压入一个函数的上下文环境，执行完毕则被退出上下文栈。函数每被执行一次就会创建一个执行上下文然后入栈。

### 5. `this`的原理以及几种不同使用场景的取值

   - 箭头函数中始终指向声明所在的上下文，不被调用方式影响
   - apply,call,bind 调用时，指向第一个参数
   - 对象调用函数时，指向该对象
   - 构造函数中，指向实例对象
   - setTimeout 等全局函数内部，始终指向 window
   - DOM Event Handler 设置为指向触发该事件的 DOM 元素

### 6. 闭包的实现原理和作用，可以列举几个开发中闭包的实际应用

   内部函数访问了外部函数的变量导致该变量保存在外部函数作用域而不被回收，形成了闭包

   防抖，节流， 单例模式

### 7. 理解堆栈溢出和内存泄漏的原理，如何防止

   - 堆栈溢出
     原因：
     - 上溢：栈满时做入栈操作；
     - 下溢：栈空时做出栈操作；

   解决方案：该现象最常见的是**无限递归**和**递归层级过深**

   针对递归函数的优化有两点优化意见，1、递归改循环，将所有运载在一个执行上下文中执行，不用生成额外的上下文。2、尾调用优化，函数返回回溯时，不用做任何额外的计算，故不用保存函数的入口环境

   ```
   // 阶乘，若用递归实现，层级不能过深
   const factorial = n => n <=1 ? 1 : n * factorial(n - 1)
   // 递归改循环
   const factorial = n => {
     let result = 1
     while (n > 1) {
       result *= n--
     }
     return result
   }
   // 尾调用优化（ES6以后）
   const factorial = (n, result = 1) => n <= 1 ? result : factorial(n - 1, n * result)
   ```

   - 内存溢出
     原因：由于疏忽或错误造成程序未能释放已经不再使用的内存

   解决方案：

   - 及时解除不再需要的引用，如闭包、定时器及全局变量等；
   - 使用 WeakSet、WeakMap，它们对于值的引用是弱引用，只要外部的引用消失，内部的引用就会自动被垃圾回收清除。

   一些实际场景：

   1. 意外的全局变量引起的内存泄漏。
      原因：全局变量，不会被回收。
      解决：使用严格模式避免。
   2. 闭包引起的内存泄漏
      原因：闭包可以维持函数内局部变量，使其得不到释放。
      解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对 dom 的引用。
   3. 没有清理的 DOM 元素引用
      原因：虽然别的地方删除了，但是对象中还存在对 dom 的引用
      解决：手动删除。
   4. 被遗忘的定时器或者回调
      原因：定时器中有 dom 的引用，即使 dom 删除了，但是定时器还在，所以内存中还是有这个 dom。
      解决：手动删除定时器和 dom。
   5. 子元素存在引用引起的内存泄漏
      原因：div 中的 ul li 得到这个 div，会间接引用某个得到的 li，那么此时因为 div 间接引用 li，即使 li 被清空，也还是在内存中，并且只要 li 不被删除，他的父元素都不会被删除。
      解决：手动删除清空。

### 8. 如何处理循环的异步操作

   `async/await`

### 9. 理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理

   - `CommonJS`
     同步加载
     导出的值是拷贝的值

   - `AMD`
     异步加载

   - `CMD`
     按需加载

   - `UMD`
     `AMD`和`CMD`都支持

   - `ES6 Module`
     模块导出是强关联
