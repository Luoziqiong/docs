## 一、JavaScript 基础

[变量和类型](https://github.com/Luoziqiong/docs/blob/master/folder/JavaScript%20%E5%9F%BA%E7%A1%80/%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E5%9E%8B.md)

### 原型和原型链

1. 理解原型设计模式以及 JavaScript 中的原型规则

原型模式：指原型实例指向创建对象的种类，并通过拷贝这些原型创建新的对象，是一种用来创建对象的模式，也就是一个对象作为另一个对象的`prototype`属性

原型规则：

- 所有引用类型（数组、对象、函数），都具有对象特征，即可自由扩展属性；
- 所有引用类型，都有一个`__proto__`属性（隐式类型），属性值是一个普通对象；
- 所有函数，都具有一个`prototype`属性（显式类型），属性值也是一个普通原型；
- 所有的引用类型（数组、对象、函数），其隐式原型指向其构造函数的显式原型；
  `(obj.__proto__ === obj.prototype)`
- 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的`__proto__`(即它的构造函数的 prototype)中去寻找；

2. instanceof 的底层实现原理，手动实现一个 instanceof

- js 中为了实现继承，每个对象都有一个`__proto__`, 指向其上个原型
- 2、函数对象会有一个 `prototype`，
- 3、所以就可以通过原型链去判断某个类型是否在其原型链上。

```

function instanceof(obj, parent) {
  let _obj = obj
  while (_obj.__proto__) {
    if (_obj.__proto__ === parent.prototype) {
      return true
    }
    _obj = _obj.__proto__
  }
  return false
}

```

4. 实现继承的几种方式以及他们的优缺点

```
function Animal(name) {
  this.name = name || '动物';
  this.eat = function() {
    console.log(this.name + '在吃饭');
  }
}
Animal.prototype.run = function() {
  console.log('running...')
}
```

1、 原型链继承

将父类的实例作为子类方法的原型

```
function Cat(name) {
  this.name = name || '喵咪';
}
Cat.prototype = new Animal();
Cat.prototype.constructor = Cat; // 手动修正构造函数

```

特点： 实现简简洁；

缺点：

- 无法给父类传参；
- 只能在继承语句之后对父类内的值进行修改；
- 所有子类实例共享父类上的属性和方法

2、 构造函数继承

没有用到原型链，将父类的方法复制一份给子类；

```
function Cat(name) {
  Animal.apply(this, arguments);
  this.name = name || 'cat';
}
```

缺点：

- 无法调用父类原型上的方法；
- 原型链上没有父类的原型,因此使用 instanceof 会返回 false；
- 每声明一个子类实例都会生成一份父类内部属性，性能差；

3、 组合继承

```
function Cat(name) {
  Animal.apply(this, arguments);
  this.name = name || 'cat';
}

Cat.prototype = new Animal();
Cat.prototype.constructor = Cat;

```

特点:
1、融合了原型链继承和构造函数的优点。

缺点：
1、融合了原型链继承和构造函数的缺点。

4、 原型式继承

模拟 Object.create 的实现。将传入的对象作为创建的对象的原型。

```
function createObj(o) {
  function F() {}
  F.prototype = o;
  return new F();
}
```

缺点：1、引用类型的属性值始终都会共享相应的值

5、 寄生式继承

创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象

```
function createObj(o) {
  let clone = Object.create(o);
  clone.sayName = function () {
    console.log('hi');
  }
  return clone;
}
```

缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。

6、 寄生组合式继承

```
function Cat(name) {
  Animal.apply(this, argument);
  this.name = name
}

function object(o) {
    function F() {}
    F.prototype = o;
    return new F();
}

function prototype(child, parent) {
    let prototype = object(parent.prototype);
    prototype.constructor = child;
    child.prototype = prototype;
}

// 关键的三步
// let F = function () {};
// F.prototype = Animal.prototype;
// Cat.prototype = new F();

prototype(Cat, Animal);
```

缺点：会调用两次父构造函数

5. 至少说出一种开源项目(如 Node)中应用原型继承的案例

6. 可以描述 new 一个对象的详细过程，手动实现一个 new 操作符

```
let obj = new Object('as')
let obj = {}
obj.__proto__ = Object.prototype
Object.call(obj, 'as')
```

7. 理解 es6 class 构造以及继承的底层实现原理

使用了寄生组合式继承

### 作用域和闭包

1. 理解词法作用域和动态作用域
   词法作用域，也可以称为静态作用域，指的是作用域是在函数定义时就被确定了。
   动态作用域，作用域在代码运行时才会被确定。|
   JS 采用的是词法作用域。

2. 上下文与作用域的关系？

当代码运行时，会产生一个对应的执行环境，在这个环境中，所有变量会被事先提出来（变量提升），有的直接赋值，有的为默认值`undefined`，代码从上往下执行，就叫做执行上下文。

JS 中有三种运行环境：

- 全局环境：代码首先进入的环境
- 函数环境：函数被调用时执行的环境
- `eval`函数

- 执行上下文生命周期

  1. 创建阶段

     (1) 生成变量对象

     (2) 建立作用域链

     (3) 确认`this`指向

  2. 执行阶段

     (1) 变量赋值

     (2) 函数引用

     (3) 执行其他代码

  3. 销毁阶段

     执行完毕出栈, 等待回收被销毁

  `JavaScript`代码执行过程分为两个阶段：

  - 代码解释阶段：由编译器完成，将代码翻译成可执行代码。
  - 代码执行阶段：有引擎完成，主要任务是执行可执行代码。

  **解释阶段**

  - 词法分析
  - 语法分析
  - 作用域规则确定

  **执行阶段**

  - 创建执行上下文
  - 执行函数代码
  - 垃圾回收

  作用域在函数定义时被确定，执行上下文是在函数执行之前创建的。

  作用域和执行上下文之间最大的区别是： **执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。**

3. 理解`JavaScript`的作用域和作用域链

作用域指的是你有权访问的变量， 对象， 函数的集合。作用域决定了你代码区块中变量和其他资源的可见性。
作用域最大的用处是隔离变量，不同作用域下面的同名变量不会有冲突。

- 全局作用域

  在代码中任何地方都能访问到的对象拥有全局作用域。比如最外层函数，最外层变量。

  `window`对象的内置属性拥有全局作用域。

- 函数作用域

  函数作用域，是指在函数内部声明的变量函数的集合。只有在该函数内部才可以访问到。

  内层作用域可以访问外层作用域，反之则不行。

  块语句不会创建新的作用域。在块语句中定义的变量将保留他们已经存在的作用域中。

- 块级作用域
  块级作用域可通过新增命令`let`和`const`声明， 所声明的变量在指定块的作用域外无法被访问。块级作用域在如下情况被创建：

- 在一个函数的内部
- 在一个代码块（由一对花括号包裹）内部

- 作用域链
  > 作用域链本质上是一个指向当前环境与上层环境的一系列变量对象的指针列表（它只引用但不实际包含变量对象），作用域链保证了当前执行环境对符合访问权限的变量和函数的有序访问。

在一个作用域中访问一个变量，如果这个变量没有在该作用域声明，此时就会往该作用域的上一级作用域（即创建该函数的作用域）去找。取到的值为离自己最近的作用域里的值。

这样就形成了一个链式结构。

3. 理解`JavaScript`的执行上下文栈，可以应用堆栈信息快速定位问题

执行上下文栈会存储执行环境，执行全局代码时，全局环境首先会被压入栈中，之后执行到函数时，会向栈中压入一个函数的上下文环境，执行完毕则被退出上下文栈。函数每被执行一次就会创建一个执行上下文然后入栈。

4. `this`的原理以及几种不同使用场景的取值

- 箭头函数中始终指向声明所在的上下文，不被调用方式影响
- apply,call,bind 调用时，指向第一个参数
- 对象调用函数时，指向该对象
- 构造函数中，指向实例对象
- setTimeout 等全局函数内部，始终指向 window
- DOM Event Handler 设置为指向触发该事件的 DOM 元素

5. 闭包的实现原理和作用，可以列举几个开发中闭包的实际应用

内部函数访问了外部函数的变量导致该变量保存在外部函数作用域而不被回收，形成了闭包

防抖，节流， 单例模式

6. 理解堆栈溢出和内存泄漏的原理，如何防止

- 堆栈溢出
  原因：
  - 上溢：栈满时做入栈操作；
  - 下溢：栈空时做出栈操作；

解决方案：该现象最常见的是**无限递归**和**递归层级过深**

针对递归函数的优化有两点优化意见，1、递归改循环，将所有运载在一个执行上下文中执行，不用生成额外的上下文。2、尾调用优化，函数返回回溯时，不用做任何额外的计算，故不用保存函数的入口环境

```
// 阶乘，若用递归实现，层级不能过深
const factorial = n => n <=1 ? 1 : n * factorial(n - 1)
// 递归改循环
const factorial = n => {
  let result = 1
  while (n > 1) {
    result *= n--
  }
  return result
}
// 尾调用优化（ES6以后）
const factorial = (n, result = 1) => n <= 1 ? result : factorial(n - 1, n * result)
```

- 内存溢出
  原因：由于疏忽或错误造成程序未能释放已经不再使用的内存

解决方案：

- 及时解除不再需要的引用，如闭包、定时器及全局变量等；
- 使用 WeakSet、WeakMap，它们对于值的引用是弱引用，只要外部的引用消失，内部的引用就会自动被垃圾回收清除。

一些实际场景：

1. 意外的全局变量引起的内存泄漏。
   原因：全局变量，不会被回收。
   解决：使用严格模式避免。
2. 闭包引起的内存泄漏
   原因：闭包可以维持函数内局部变量，使其得不到释放。
   解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对 dom 的引用。
3. 没有清理的 DOM 元素引用
   原因：虽然别的地方删除了，但是对象中还存在对 dom 的引用
   解决：手动删除。
4. 被遗忘的定时器或者回调
   原因：定时器中有 dom 的引用，即使 dom 删除了，但是定时器还在，所以内存中还是有这个 dom。
   解决：手动删除定时器和 dom。
5. 子元素存在引用引起的内存泄漏
   原因：div 中的 ul li 得到这个 div，会间接引用某个得到的 li，那么此时因为 div 间接引用 li，即使 li 被清空，也还是在内存中，并且只要 li 不被删除，他的父元素都不会被删除。
   解决：手动删除清空。

6. 如何处理循环的异步操作

`async/await`

9. 理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理

- `CommonJS`
  同步加载
  导出的值是拷贝的值

- `AMD`
  异步加载

- `CMD`
  按需加载

- `UMD`
  `AMD`和`CMD`都支持

- `ES6 Module`
  模块导出是强关联

### 执行机制

1. 为何`try`里面放`return`，`finally`还会执行，理解其内部机制

   在 `try-catch` 的机制中，当 `try` 或者 `catch` 中有 `return`，都会先执行 `finally` 里的代码，并且 `finally` 中没有 `return` 才会去执行 `try` 或者 `catch` 中的 `return。`

2. `JavaScript`如何实现异步编程，可以详细描述`EventLoop`机制

   JS 单线程是单线程，为了解决 JS 代码长时间运行（比如死循环），导致整个页面卡住，其他任务无法执行。
   为了解决这个问题，JS 将任务的执行模式分为两种：同步和异步。

JS 中实现异步编程的 4 种方式：
（1）回调函数
（2）事件监听
（3）发布/订阅
（4）Promise 对象
（5）生成器 Generators/ yield
（6）async/await

`EventLoop`机制：宏任务和微任务

3. 宏任务和微任务分别有哪些

- 宏任务
  整体 JS 代码；
  事件回调；
  XHR 回调；
  定时器（setTimeout, setInterval, setImmediate）；
  IO 操作；
  UI render；

- 微任务
  promise 回调；
  MutationObserver；
  process.nextTick;

4. 可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法

5. 使用`Promise`实现串行
   `Promise.all`
   `Array.reduce`
   `async/await`

6. `Node`与浏览器`EventLoop`的差异

- `Node.js`内，`microtask` 在事件循环的各个阶段之间执行；浏览器端，`microtask` 在事件循环的 `macrotask` 执行完之后执行。

- `Node 10`及之前版本，`timers`阶段若有多个定时器回调，则全部执行之后再去检查微任务队列；而`Node11`及之后版本，则是执行一个宏任务就去检查微任务队列，跟浏览器端表现趋于一致。

7. 如何在保证页面运行流畅的情况下处理海量数据
   虚拟滚动列表

### 语法和 API

1. 理解`ECMAScript`和`JavaScript`的关系

`ECMAScript`是规范，`JavaScript`是语言

`ECMAScript`提供了脚本语言需要遵守的规则、细节和规范

2. 熟练运用`es5、es6`提供的语法规范

3. 熟练掌握`JavaScript`提供的全局对象（例如`Date、Math`）、全局函数（例如`decodeURI、isNaN`）、全局属性（例如`Infinity、undefined`）

4. 熟练应用`map`、`reduce`、`filter` 等高阶函数解决问题

5. `setInterval`需要注意的点，使用`settimeout`实现`setInterval`

需要在离开页面时手动清除计时器。

6. `JavaScript`提供的正则表达式 API、可以使用正则表达式（邮箱校验、URL 解析、去重等）解决常见问题

7. `JavaScript`异常处理的方式，统一的异常处理方案
   [参考文章](https://lucifer.ren/blog/2020/06/14/error-catch/)

- 客户端收集
- window.onerror

## 二、HTML 和 CSS

### HTML

1. 从规范的角度理解`HTML`，从分类和语义的角度使用标签

   - 为什么要语义化?

   a. 为了在没有 CSS 的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看；

   b. 用户体验：例如 title、alt 用于解释名词或解释图片信息的标签尽量填写有含义的词语、label 标签的活用；

   c. 有利于 SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；

   d. 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以有意义的方式来渲染网页；

   e. 便于团队开发和维护，语义化更具可读性，遵循 W3C 标准的团队都遵循这个标准，可以减少差异化。

2. 常用页面标签的默认样式、自带属性、不同浏览器的差异、处理浏览器兼容问题的方式

3. 元信息类标签（`base`, `link`,`title`, `meta`）的使用目的和配置方法

- `base`指定了一个 url 作为基准
- `link`用于引入外部文档
- `title`文档标题
- `meta`主要用于描述网页，与之对应的属性值为 content，content 中的内容主要是便于搜索引擎机器人查找信息和分类信息的。

4. `HTML5`离线缓存原理
   HTML5 离线存储是基于一个 manifest 文件（缓存清单文件，后缀为`.appcache`）的缓存机制（不是存储技术），通过这个文件上的清单解析离线存储资源，这些资源就会想 cookie 一样被存储下来。之后网络处于离线状态时，浏览器关于通过被离线存储的数据进行页面展示。

5. 可以使用`canvas API`、`SVG`等绘制高性能动画

### CSS

1. `CSS`盒模型，在不同浏览器的差异
   IE 盒子模型是 border-box(width = content + padding + border),
   标准盒模型是 content-box

2. `CSS`所有选择器及其优先级、使用场景，哪些可以继承，如何运用@规则

- 选择器

  - 通用选择器 \*
  - 标签选择器（元素选择器／类型选择器）
  - 类选择器
  - ID 选择器
  - 属性选择器-[att]（IE6-不支持）
  - 伪类、选择器、伪元素选择器
  - 子选择器（>）
  - 后代（包含）选择器（空格）
  - 相邻兄弟选择器（+）
  - 通用兄弟选择器（~）匹配 E 元素之后的所有同级元素 F（无论直接相邻与否）

- 继承

  - 不可以继承的属性有：`display、margin、border、padding、background、height、width、min-height、max-height、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-break-before`
  - 所有元素可继承：`visibility、cursor`
  - 内联元素可继承：`letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-weight、font-style、font-variant、text-decoration、text-transform、direction`
  - 终端块状元素可继承：`text-indent、text-align`
  - 列表元素可继承：`list-style、list-style-type、list-style-position、list-style-image`
  - 表格元素可继承：`border-collapse`

- 样式优先级：!important > 内联样式 > ID 选择器 > 类选择器、伪类选择器 > 标签选择器、伪元素选择器 > 通配符选择器

3. `CSS`伪类和伪元素有哪些，他们的区别和实际应用

- 伪类
  :hover, :focus, :last-child,...

- 伪元素
  ::before, ::after, ::first-letter, ::first-line, ::selection, ::placeHolder, ::backdrop

- 区别
  伪类是元素已经在文档中，加上用于区分某种状态
  伪元素是原本不在文档结构中存在，写了之后会有新的元素加入的效果。

4. `HTML`文档流的排版规则，`CSS`几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理

- `HTML`分两种元素

  - 行内元素
  - 块级元素

  他们在文档中从上到下，从左到右排列，其中块级元素独占一行。
  但是浮动 float 和定位 position 可以改变默认文档流。

`CSS` 定位规则，

- relative 相对定位
- absolute 绝对定位， 参照物-离自己最近的非 static 的父元素，若没有则相对于浏览器窗口
- fixed 固定定位，参照物-浏览器窗口

5. 水平垂直居中的解决方案，可以实现 6 种以上并对比它们的优缺点

```
<div class=container><div class="box"></div></div>
```

- 绝对定位 + margin: auto

```
.container {
  width: 100px;
  height: 100px;
  position: relative;
}
.box {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  margin: auto;
  width: 50px;
  height: 50px;
}
```

- 绝对定位 + transform

```
.container {
  width: 100px;
  height: 100px;
  position: relative;
}
.box {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 50px;
  height: 50px;
 transform: translate(-50%, -50%);
}
```

- flex

```
.container {
  width: 100px;
  height: 100px;
  display: flex;
  justify-content: center;
  align-items: center;
}
.box {
  width: 50px;
  height: 50px;
}
```

- 文本垂直居中

```
.container {
  width: 100%;
  height: 40px;
  text-align: center;
  line-height: 40px; // 行高与父元素高度相同
}
```

- 表格布局

6. `BFC`实现原理，可以解决的问题，如何创建`BFC`
   > > 块格式化上下文（Block Formatting Context，BFC） 是 Web 页面的可视化 CSS 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 -- 《MDN》

如果一个元素具有 `BFC`，内部子元素再怎么翻江倒海、翻云覆雨，都不会影响外部的元素。所以，`BFC` 元素是不可能发生 `margin` 重叠的，因为 `margin` 重叠是会影响外面的元素的;`BFC` 元素也可以用来清除浮动的影响，因为如果不清除，子元素浮动则父元素高度塌陷，必然会影响后面元素布局和定位，这显然有违 `BFC`元素的子元素不会影响外部元素的设定。

- 创建
  - 根元素或者包含根元素的元素
  - 浮动元素
  - 绝对定位元素
  - 行内块元素
  - 表格单元格
  - 表格标题
  - 匿名表格单元格元素
  - overflow 值不为 visible 的块元素
  - display 值不为 flow-root 的元素
  - contain 值为 layout、content 或 strict 的元素
  - 弹性元素
  - 网格元素
  - 多列容器
  - colum-span 为 all 的元素始终会创建一个新的 BFC，即使该匀速没有包裹在一个多列容器中。

7. 可使用`CSS`函数复用代码，实现特殊效果

8. `PostCSS`,`Sass`,`Less`的异同，以及配置，至少掌握一种

9. `CSS`模块化、如何配置按需加载、如何防止`CSS`阻塞渲染

10. 熟练使用`CSS`实现常见动画，如渐变、移动、旋转、缩放等等

11. `CSS`浏览器兼容性写法，了解不同`API`在不同浏览器下的兼容性情况

12. 掌握一套完整的响应式布局方案

### 手写

1. 手写瀑布流效果
   flex, columns

2. 使用`CSS`绘制几何图形（图形、三角形、扇形、菱形等）

3. 使用纯`CSS`实现曲线运动（贝塞尔曲线）

4. 实现常用布局（三栏、圣杯、双飞翼、吸顶），可以说出多种方式并理解其优缺点

## 三、计算机基础

### 编译原理

1. 理解代码到底是什么，计算机如何将代码转换为可以的目标程序

2. 正则表达式的匹配原理和性能优化

3. 如何将`JavaScript`代码解析成抽象语法树（`AST`）

4. `base64`的编码原理

5. 几种进制的相互转换计算方法，在`JavaScript`中如何表示和转换

### 网络协议

1. 理解什么是协议，了解`TCP/IP`网络协议族的构成，每层协议在应用程序中发挥的作用

2. 三次握手和四次挥手详细原理，为什么要使用这种机制

3. 有哪些协议是可靠的，`TCP`有哪些手段保证可靠交付

4. `DNS`的作用，`DNS`解析的详细过程，`DNS`优化原理

5. `CDN`的作用和原理

- 原理
  广泛的采用并把各种缓存服务器分布到用户访问相对集中的地区或网络中，当用户访问网络时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器响应用户的请求。

过程： - 用户输入 URL 回车，DNS 解析后将域名解析权交给 CNAME 指向的 CDN 专用 DNS 服务器 - 解析后获得全局负载均衡设备的 IP 地址，用户向全局负载均衡设备发送内容访问请求 - 全局负载均衡设备将实时地根据网络流量和各个节点的连接、负载状况及到用户的距离和响应时间等信息把用户的请求重新导向到离用户最近的服务节点上 - 用户获得所需内容

- 作用
  - 解决网络拥挤状况
  - 提高用户访问网站响应速度

6. `HTTP`请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么

7. `HTTP`所有状态码的具体含义，看到异常状态码能快速定位问题

8. `HTTP1.1`, `HTTP2.0`带来的改变

9. `HTTPS`的加密原理，如何开启`HTTPS`，如何劫持`HTTPS`请求

10. 理解`WebSocket`协议的底层原理，与`HTTP`的区别

### 设计模式

1. 熟练使用前端常用设计模式编写代码，如单例模式、装饰器模式、代理模式等

2. 发布订阅模式和观察者模式的异同以及实际应用

3. 可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用

## 四、数据结构和算法

### `JavaScript`编码能力

1. 多种方式实现、扁平化、对比优缺点
2. 多种方式实现深拷贝、对比优缺点
3. 手写函数柯里化工具函数、并理解其应用场景和优势
4. 手写函数防抖节流工具函数、并理解其内部原理和应用场景
5. 实现一个`sleep`函数

### 手动实现前端轮子

1. 手动实现`call`、`apply`、`bind`
2. 手动实现符合`Promise/A+`规范的`Promise`、手动实现`async/await`
3. 手写一个`EventEmitter`实现事件发布、订阅
4. 可以说出两种实现双向绑定的方案、可以手动实现
5. 手写`JSON.stringify`、`JSON.parse`
6. 手写一个模板引擎，并能解释其中原理
7. 手写一个`懒加载`、`下拉刷新`、`上拉加载`、`预加载`等效果

### 数据结构

1. 理解常见数据结构的特点，以及他们在不同场景下使用的优缺点
2. 理解`数组`、`字符串`的存储原理，并熟练应用他们解决问题
3. 理解`二叉树`、`栈`、`队列`、`哈希表`的基本结构和特点，并可以应用它解决问题
4. 了解`图`和`堆`的基本结构和使用场景

### 算法

1. 可计算一个算法时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗
2. 至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度
3. 了解递归和循环的优缺点、应用场景，并可在开发中熟练应用
4. 可应用`回溯算法`，`贪心算法`，`分治算法`，`动态规划`等解决复杂问题
5. 前端处理海量数据的算法方案

## 五、运行环境

### 浏览器 API

1. 浏览器提供的符合`W3C`标准的`DOM`操作`API`、浏览器差异、兼容性
2. 浏览器提供的浏览器对象模型（`BOM`）提供的所有全局`API`、浏览器差异、兼容性
3. 大量`DOM`操作，海量数据的性能优化（合并操作、`Diff`、`requestAnimationFrame`等）
4. 浏览器海量数据存储、操作性能优化
5. DOM 事件流的具体实现机制、不同浏览器的差异、事件代理
6. 前端发起网络请求的几种方式及其底层实现原理，可以手写原生`ajax`，`fetch`，可以熟练使用第三方库
7. 浏览器的同源策略，如何避免同源策源，几种方式的异同点以及如何选型

- 同源策略：协议+域名+端口 三者相同，则认为是同源

8. 浏览器提供的几种存储机制、优缺点、开发中的正确的选择
9. 浏览器跨标签通信

10. 浏览器内核
    IE: trident 内核
    Firefox：gecko 内核
    Safari：webkit 内核
    Opera：以前是 presto 内核，Opera 现已改用 Google Chrome 的 Blink 内核
    Chrome：Blink(基于 webkit，Google 与 Opera Software 共同开发)

### 浏览器原理

1. 各浏览器使用的`JavaScript`引擎以及它们的异同点，如何在代码中进行区分
2. 请求数据到请求结束与服务器进行了几次交互
3. 可详细描述浏览器从输入`URL`到页面展现的详细过程
4. 浏览器解析`HTML`代码的原理，以及构建`DOM`树的流程
5. 浏览器如何解析 CSS 规则，并将其应用在 DOM 树上
6. 浏览器如何将解析好的带有样式的 DOM 树进行绘制
7. 浏览器的运行机制，如何配置资源异步同步加载
8. 浏览器回流与重绘的底层原理，引发原因，如何有效避免

9. 浏览器的垃圾回收机制，如何避免内存泄露

传统浏览器的垃圾回收机制：

- 标记清除：变量进入环境时标记为‘进入环境’，离开环境时标记为‘离开环境’，回收是标记为‘离开环境’的变量会被回收。
- 引用计数：根据变量被引用数为其计数，引用数为 0 的变量在回收时会被清除

V8 引擎回收策略：
由于垃圾回收的事件，

10. 浏览器采用的缓存方案，如何选择和控制合适的缓存方案
    localStorage sessionStorage

### Node

1. 理解`Node`在应用程序中的作用，可以使用`Node`搭建前端运行环境、使用`Node`操作文件、操作数据库等等
2. 掌握一种`Node`开发框架，如`Express`、`Express`和`Koa`的区别
3. 熟练使用`Node`提供的`API`的`Path`、`Http`、`ChildProcess`等并理解其实现原理
4. `Node`的底层运行原理和浏览器的异同
5. `Node`事件驱动、非阻塞机制的实现原理

## 六、框架和类库

### TypeScript

1. 理解泛型、接口等面向对象的相关概念，`Typescript`对面向对象理念的实现
2. 理解使用`Typescript`的好处，并掌握`Typescript`基础语法
3. `Typescript`的规则检测原理
4. 可以在`React`、`Vue`等框架中使用`TypeScript`进行开发

### React

1. `React`和`Vue`选项和优缺点、核心架构的区别
2. `React`中`setState`的执行机制，如何有效的管理状态
3. `React`的事件底层实现机制
4. `React`的虚拟`DOM`和`Diff`算法的内部实现
5. `React`的`Fiber`工作原理，解决了什么问题
6. `React Router`和`Vue Router`的底层实现原理，动态加载实现原理
7. 可熟练应用`React API`、`生命周期`等，可应用`HOC`、`render props`、`Hooks`等高阶用法解决问题
8. 基于`React`的特性的原理，可以手动实现一个简单的`React`

### Vue

1. 熟练使用`Vue`的`API`、`生命周期`、`钩子函数`
2. `MVVM`框架设计理念
3. `Vue`双向绑定实现原理、`Diff`算法的内部实现
4. `Vue`的事件机制
5. 从`template`转换成真实`DOM`的实现机制

### 多端开发

1. 单页面应用（`SPA`）的原理和优缺点，掌握一种快速开发`SPA`的方案
2. 理解`viewport`、`em`、`rem`的原理和用法，`分辨率`、`px`、`ppi`、`dpi`、`dp`的区别和实际应用
3. 移动端页面适配解决方案、不同机型适配方案
4. 掌握一种`JavaScript`移动客户端开发技术，如`React Native`；可以搭建`React Native`开发环境，熟练进行开发，可理解`React Native`的运作原理，不同端适配
5. 掌握一种`JavaScript PC`客户端开发技术，如`Electron`；可搭建`Electron`开发环境，熟练进行开发，可理解`Electron`的运作原理
6. 掌握一种小程序开发框架或原生小程序开发
7. 理解多端框架的内部实现原理，至少了解一个多端框架的使用

### 数据流管理

1. 掌握`React`和`Vue`传统的跨组件通信方案，对比采用数据流管理框架的异同
2. 熟练使用`Redux`管理数据流，并理解其实现原理，中间件实现原理
3. 熟练使用`Mobx`管理数据流，并理解其实现原理，相比`Redux`有什么优势
4. 熟练使用`Vuex`管理数据流，并理解其实现原理
5. 以上数据流方案的异同和优缺点，不同情况下的技术选型

### 实用库

1. 至少掌握一种`UI`组件框架，如`antd design`，理解其设计理念和底层实现
2. 掌握一种图标绘制框架，如`Echart`，理解其设计理念、底层实现，可以自己实现图标
3. 掌握一种`GIS`开发框架，如`百度地图API`
4. 掌握一种可视化开发框架，如`Three.js`、`D3`
5. 工具函数库，`loadsh`、`underscore`、`moment`等。理解使用的工具类或工具函数的具体实现原理

### 开发和调试

1. 熟练使用个浏览器提供的工具
2. 熟练使用一种代理工具实现请求代理、抓包
3. 可以使用`Android` 、 `IOS`模拟器进行调试，并掌握一种真机调试方案
4. 了解`Vue`、`React`等框架调试工具的使用

## 七、前端工程

### 项目构建

1. 理解 `npm、yarn` 依赖包管理的原理，两者的区别
2. 可以使用 `npm` 运行自定义脚本

3. 理解 `Babel、ESLint、webpack` 等工具在项目中承担的作用

4. `ESLint` 规则检测原理，常用的 `ESLint` 配置

5. `Babel` 的核心原理，可以自己编写一个 `Babel` 插件

6. 可以配置一种前端代码兼容方案，如 `Polyfill`

7. `Webpack` 的编译原理、构建流程、热更新原理，`chunk`、`bundle` 和 `module` 的区别和应用

8. 可熟练配置已有的 `loaders` 和 `plugins` 解决问题，可以自己编写 `loaders` 和 `plugins`

### nginx

1. 正向代理与反向代理的特点和实例

2. 可手动搭建一个简单的 `nginx` 服务器、

3. 熟练应用常用的 `nginx` 内置变量，掌握常用的匹配规则写法

4. 可以用 `nginx` 实现请求过滤、配置 `gzip`、负载均衡等，并能解释其内部原理

### 开发提速

1. 熟练掌握一种接口管理、接口`mock`工具的使用，如`yapi`

2. 掌握一种高效的日志埋点方案，可快速使用日志查询工具定位线上问题

3. 理解`TDD`与`BDD`模式，至少会使用一种前端单元测试框架

### 版本控制

1. 理解`Git`的核心原理、工作流程、和 SVN 的区别

2. 熟练使用常规的`Git`命令、`git rebase`、`git stash`等进阶命令

3. 可以快速解决线上分支回滚、线上分支错误合并等复杂问题

### 持续继承

1. 理解`CI/CD`技术的意义，至少熟练掌握一种`CI/CD`工具的使用，如`Jenkins`

2. 可以独自完成架构设计、技术选型、环境搭建、全流程开发、部署上线等一套完整的开发流程（包括`Web`应用、移动客户端应用、`PC`客户端应用、小程序、`H5`等等）

## 八、项目和业务

### 后端技能

1. 了解后端的开发方式，在应用程序中的作用，至少会使用一种后端语言

2. 掌握数据最终在数据库中是如何落地存储的，能看懂表结构设计、表之间的关联，至少会使用一种数据库

### 性能优化

1. 了解前端性能衡量指标、性能监控要点，掌握一种前端性能监控方案

2. 了解常见的`Web`、`App`性能优化方案

3. `SEO`排名规则、`SEO`优化方案、前后端分离的`SEO`

4. `SSR`实现方案、优缺点、及其性能优化

5. `Webpack`的性能优化方案

6. `Canvas`性能优化方案

7. `React`、`Vue`等框架使用性能优化方案

### 前端安全

1. `XSS`攻击的原理、分类、具体案例，前端如何防御

2. `CSRF`攻击的原理、具体案例，前端如何防御

3. `HTTP`劫持、页面劫持的原理、防御措施

### 业务相关

1. 能理解所开发项目的整体业务形态、业务目标、业务架构，可以快速定位线上业务问题

2. 能理解所开发项目整体的技术架构、能快读的根据新需求进行开发规划、能快速根据业务报警、线上日志等定位并解决线上技术问题

3. 可以将自己的想法或新技术在业务中落地实践，尽量在团队中拥有一定的不可替代性
